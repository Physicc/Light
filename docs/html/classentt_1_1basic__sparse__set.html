<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Light: entt::basic_sparse_set&lt; Entity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Light
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Lightweight game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>entt</b></li><li class="navelem"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classentt_1_1basic__sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">entt::basic_sparse_set&lt; Entity &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="classentt_1_1basic__sparse__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="entt_8hpp_source.html">entt.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::basic_sparse_set&lt; Entity &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classentt_1_1basic__sparse__set__inherit__graph.png" border="0" usemap="#entt_1_1basic__sparse__set_3_01Entity_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a350b507e85eea1ee4f562374b1d47e42"><td class="memItemLeft" align="right" valign="top"><a id="a350b507e85eea1ee4f562374b1d47e42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> = Entity</td></tr>
<tr class="memdesc:a350b507e85eea1ee4f562374b1d47e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier. <br /></td></tr>
<tr class="separator:a350b507e85eea1ee4f562374b1d47e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b021680642656b85abb01e503cf1361"><td class="memItemLeft" align="right" valign="top"><a id="a4b021680642656b85abb01e503cf1361"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a4b021680642656b85abb01e503cf1361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:a4b021680642656b85abb01e503cf1361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec801822e07322ff37412472bc040a"><td class="memItemLeft" align="right" valign="top"><a id="ac1ec801822e07322ff37412472bc040a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a> = sparse_set_iterator</td></tr>
<tr class="memdesc:ac1ec801822e07322ff37412472bc040a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type. <br /></td></tr>
<tr class="separator:ac1ec801822e07322ff37412472bc040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083b5d1855348959c94507c62e4560e3"><td class="memItemLeft" align="right" valign="top"><a id="a083b5d1855348959c94507c62e4560e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a083b5d1855348959c94507c62e4560e3">reverse_iterator</a> = const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> *</td></tr>
<tr class="memdesc:a083b5d1855348959c94507c62e4560e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type. <br /></td></tr>
<tr class="separator:a083b5d1855348959c94507c62e4560e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac10d76d13a4914ef750f489d57c7a030"><td class="memItemLeft" align="right" valign="top"><a id="ac10d76d13a4914ef750f489d57c7a030"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac10d76d13a4914ef750f489d57c7a030">basic_sparse_set</a> ()=default</td></tr>
<tr class="memdesc:ac10d76d13a4914ef750f489d57c7a030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac10d76d13a4914ef750f489d57c7a030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119fca5d1da75408c04a6bf1bea99244"><td class="memItemLeft" align="right" valign="top"><a id="a119fca5d1da75408c04a6bf1bea99244"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a119fca5d1da75408c04a6bf1bea99244">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a119fca5d1da75408c04a6bf1bea99244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:a119fca5d1da75408c04a6bf1bea99244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4d3e05fcaf30227ce50c7f96a10c8"><td class="memItemLeft" align="right" valign="top"><a id="af7c4d3e05fcaf30227ce50c7f96a10c8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af7c4d3e05fcaf30227ce50c7f96a10c8">~basic_sparse_set</a> ()=default</td></tr>
<tr class="memdesc:af7c4d3e05fcaf30227ce50c7f96a10c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:af7c4d3e05fcaf30227ce50c7f96a10c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee2299701078a3d87ee4fbc61a11c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8ee2299701078a3d87ee4fbc61a11c61">operator=</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a8ee2299701078a3d87ee4fbc61a11c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator.  <a href="classentt_1_1basic__sparse__set.html#a8ee2299701078a3d87ee4fbc61a11c61">More...</a><br /></td></tr>
<tr class="separator:a8ee2299701078a3d87ee4fbc61a11c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac69bb690227ebebd22fd6c998ba69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abbac69bb690227ebebd22fd6c998ba69">reserve</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> cap)</td></tr>
<tr class="memdesc:abbac69bb690227ebebd22fd6c998ba69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a sparse set.  <a href="classentt_1_1basic__sparse__set.html#abbac69bb690227ebebd22fd6c998ba69">More...</a><br /></td></tr>
<tr class="separator:abbac69bb690227ebebd22fd6c998ba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78ef32caf9f42fae6840f51de63a3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae78ef32caf9f42fae6840f51de63a3c9">capacity</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ae78ef32caf9f42fae6840f51de63a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a sparse set has currently allocated space for.  <a href="classentt_1_1basic__sparse__set.html#ae78ef32caf9f42fae6840f51de63a3c9">More...</a><br /></td></tr>
<tr class="separator:ae78ef32caf9f42fae6840f51de63a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a211d7468b9077d5fffd93aaf3ab212"><td class="memItemLeft" align="right" valign="top"><a id="a2a211d7468b9077d5fffd93aaf3ab212"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2a211d7468b9077d5fffd93aaf3ab212">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a2a211d7468b9077d5fffd93aaf3ab212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity. <br /></td></tr>
<tr class="separator:a2a211d7468b9077d5fffd93aaf3ab212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242cef78b4cdc4ad16844aa06b31bdd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a242cef78b4cdc4ad16844aa06b31bdd2">extent</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a242cef78b4cdc4ad16844aa06b31bdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a242cef78b4cdc4ad16844aa06b31bdd2">More...</a><br /></td></tr>
<tr class="separator:a242cef78b4cdc4ad16844aa06b31bdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd2179ea7088d14f5ce69d7494709d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1dd2179ea7088d14f5ce69d7494709d3">size</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a1dd2179ea7088d14f5ce69d7494709d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a1dd2179ea7088d14f5ce69d7494709d3">More...</a><br /></td></tr>
<tr class="separator:a1dd2179ea7088d14f5ce69d7494709d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1357c27ba3d56e2d1ec10247f861640a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1357c27ba3d56e2d1ec10247f861640a">empty</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a1357c27ba3d56e2d1ec10247f861640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <a href="classentt_1_1basic__sparse__set.html#a1357c27ba3d56e2d1ec10247f861640a">More...</a><br /></td></tr>
<tr class="separator:a1357c27ba3d56e2d1ec10247f861640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268e0489bfee6161c78e7ecf6c343312"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a268e0489bfee6161c78e7ecf6c343312">data</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a268e0489bfee6161c78e7ecf6c343312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#a268e0489bfee6161c78e7ecf6c343312">More...</a><br /></td></tr>
<tr class="separator:a268e0489bfee6161c78e7ecf6c343312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161e68e4281c40c39175499c26efdfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3161e68e4281c40c39175499c26efdfd">begin</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a3161e68e4281c40c39175499c26efdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="classentt_1_1basic__sparse__set.html#a3161e68e4281c40c39175499c26efdfd">More...</a><br /></td></tr>
<tr class="separator:a3161e68e4281c40c39175499c26efdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed626f4ec3c49322751cd93e7eeeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a11ed626f4ec3c49322751cd93e7eeeba">end</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a11ed626f4ec3c49322751cd93e7eeeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="classentt_1_1basic__sparse__set.html#a11ed626f4ec3c49322751cd93e7eeeba">More...</a><br /></td></tr>
<tr class="separator:a11ed626f4ec3c49322751cd93e7eeeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dba8a5bd4d928ad24174537e9bccba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a083b5d1855348959c94507c62e4560e3">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9dba8a5bd4d928ad24174537e9bccba5">rbegin</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a9dba8a5bd4d928ad24174537e9bccba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classentt_1_1basic__sparse__set.html#a9dba8a5bd4d928ad24174537e9bccba5">More...</a><br /></td></tr>
<tr class="separator:a9dba8a5bd4d928ad24174537e9bccba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94af829f6ac763b37df719b43a885ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a083b5d1855348959c94507c62e4560e3">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a94af829f6ac763b37df719b43a885ae4">rend</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a94af829f6ac763b37df719b43a885ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="classentt_1_1basic__sparse__set.html#a94af829f6ac763b37df719b43a885ae4">More...</a><br /></td></tr>
<tr class="separator:a94af829f6ac763b37df719b43a885ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c8802dc54456ad6c5ad29cdb370529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aa4c8802dc54456ad6c5ad29cdb370529">find</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> entt) const</td></tr>
<tr class="memdesc:aa4c8802dc54456ad6c5ad29cdb370529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <a href="classentt_1_1basic__sparse__set.html#aa4c8802dc54456ad6c5ad29cdb370529">More...</a><br /></td></tr>
<tr class="separator:aa4c8802dc54456ad6c5ad29cdb370529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb829883e484fac948f907fdf5363d11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aeb829883e484fac948f907fdf5363d11">contains</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> entt) const</td></tr>
<tr class="memdesc:aeb829883e484fac948f907fdf5363d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <a href="classentt_1_1basic__sparse__set.html#aeb829883e484fac948f907fdf5363d11">More...</a><br /></td></tr>
<tr class="separator:aeb829883e484fac948f907fdf5363d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0f4c36135a1d52f4993701c070b9a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abb0f4c36135a1d52f4993701c070b9a3">index</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> entt) const</td></tr>
<tr class="memdesc:abb0f4c36135a1d52f4993701c070b9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <a href="classentt_1_1basic__sparse__set.html#abb0f4c36135a1d52f4993701c070b9a3">More...</a><br /></td></tr>
<tr class="separator:abb0f4c36135a1d52f4993701c070b9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c07ea42869c1ac22a3ed27ebe6d4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a59c07ea42869c1ac22a3ed27ebe6d4e3">at</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> pos) const</td></tr>
<tr class="memdesc:a59c07ea42869c1ac22a3ed27ebe6d4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, with bounds checking.  <a href="classentt_1_1basic__sparse__set.html#a59c07ea42869c1ac22a3ed27ebe6d4e3">More...</a><br /></td></tr>
<tr class="separator:a59c07ea42869c1ac22a3ed27ebe6d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a42337d592c6ffb548b6cdeb3c990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af47a42337d592c6ffb548b6cdeb3c990">operator[]</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> pos) const</td></tr>
<tr class="memdesc:af47a42337d592c6ffb548b6cdeb3c990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, without bounds checking.  <a href="classentt_1_1basic__sparse__set.html#af47a42337d592c6ffb548b6cdeb3c990">More...</a><br /></td></tr>
<tr class="separator:af47a42337d592c6ffb548b6cdeb3c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5855f240d4e380467e6422edb9e06496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a5855f240d4e380467e6422edb9e06496">emplace</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> entt)</td></tr>
<tr class="memdesc:a5855f240d4e380467e6422edb9e06496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a5855f240d4e380467e6422edb9e06496">More...</a><br /></td></tr>
<tr class="separator:a5855f240d4e380467e6422edb9e06496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c63e08ff399077c5c8b9beef794e80a"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a4c63e08ff399077c5c8b9beef794e80a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a4c63e08ff399077c5c8b9beef794e80a">insert</a> (It first, It last)</td></tr>
<tr class="memdesc:a4c63e08ff399077c5c8b9beef794e80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one or more entities to a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a4c63e08ff399077c5c8b9beef794e80a">More...</a><br /></td></tr>
<tr class="separator:a4c63e08ff399077c5c8b9beef794e80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0b4d393afe8b75c7d9d64eec662a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9b0b4d393afe8b75c7d9d64eec662a13">remove</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> entt, void *ud=nullptr)</td></tr>
<tr class="memdesc:a9b0b4d393afe8b75c7d9d64eec662a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a9b0b4d393afe8b75c7d9d64eec662a13">More...</a><br /></td></tr>
<tr class="separator:a9b0b4d393afe8b75c7d9d64eec662a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be76483883a469befd13285dc286ba0"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a6be76483883a469befd13285dc286ba0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a6be76483883a469befd13285dc286ba0">remove</a> (It first, It last, void *ud=nullptr)</td></tr>
<tr class="memdesc:a6be76483883a469befd13285dc286ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes multiple entities from a pool.  <a href="classentt_1_1basic__sparse__set.html#a6be76483883a469befd13285dc286ba0">More...</a><br /></td></tr>
<tr class="separator:a6be76483883a469befd13285dc286ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa344d6da890c4e8a587f186a2872b5b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aa344d6da890c4e8a587f186a2872b5b9">swap</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> lhs, const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> rhs)</td></tr>
<tr class="memdesc:aa344d6da890c4e8a587f186a2872b5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#aa344d6da890c4e8a587f186a2872b5b9">More...</a><br /></td></tr>
<tr class="separator:aa344d6da890c4e8a587f186a2872b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172cbcd7ced65b6649224ca47b6d524"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a9172cbcd7ced65b6649224ca47b6d524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9172cbcd7ced65b6649224ca47b6d524">sort_n</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> count, Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9172cbcd7ced65b6649224ca47b6d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the first count elements according to the given comparison function.  <a href="classentt_1_1basic__sparse__set.html#a9172cbcd7ced65b6649224ca47b6d524">More...</a><br /></td></tr>
<tr class="separator:a9172cbcd7ced65b6649224ca47b6d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4d0296516d1d269b3a1e77b3632048"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a2a4d0296516d1d269b3a1e77b3632048"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2a4d0296516d1d269b3a1e77b3632048">sort</a> (Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2a4d0296516d1d269b3a1e77b3632048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements according to the given comparison function.  <a href="classentt_1_1basic__sparse__set.html#a2a4d0296516d1d269b3a1e77b3632048">More...</a><br /></td></tr>
<tr class="separator:a2a4d0296516d1d269b3a1e77b3632048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a588fd9b1e9288196c6786b5668e2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0a588fd9b1e9288196c6786b5668e2f3">respect</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a0a588fd9b1e9288196c6786b5668e2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in another sparse set.  <a href="classentt_1_1basic__sparse__set.html#a0a588fd9b1e9288196c6786b5668e2f3">More...</a><br /></td></tr>
<tr class="separator:a0a588fd9b1e9288196c6786b5668e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22428127d7eed30332291187b8822a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a22428127d7eed30332291187b8822a4a">clear</a> (void *ud=nullptr) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a22428127d7eed30332291187b8822a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a22428127d7eed30332291187b8822a4a">More...</a><br /></td></tr>
<tr class="separator:a22428127d7eed30332291187b8822a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7ce171261140444caf3e940bc2dae122"><td class="memItemLeft" align="right" valign="top"><a id="a7ce171261140444caf3e940bc2dae122"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a7ce171261140444caf3e940bc2dae122">swap_at</a> (const std::size_t, const std::size_t)</td></tr>
<tr class="memdesc:a7ce171261140444caf3e940bc2dae122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in the internal packed array. <br /></td></tr>
<tr class="separator:a7ce171261140444caf3e940bc2dae122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae094f1bd8c3b2ef414cd65553e01ed2"><td class="memItemLeft" align="right" valign="top"><a id="aae094f1bd8c3b2ef414cd65553e01ed2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aae094f1bd8c3b2ef414cd65553e01ed2">swap_and_pop</a> (const std::size_t, void *)</td></tr>
<tr class="memdesc:aae094f1bd8c3b2ef414cd65553e01ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to remove an entity from the internal packed array. <br /></td></tr>
<tr class="separator:aae094f1bd8c3b2ef414cd65553e01ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Entity&gt;<br />
class entt::basic_sparse_set&lt; Entity &gt;</h3>

<p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br  />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br  />
 This is largely used by the registry to offer users the fastest access ever to the components. Views and groups in general are almost entirely designed around sparse sets.</p>
<p>This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>Internal data structures arrange elements to maximize performance. There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a59c07ea42869c1ac22a3ed27ebe6d4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c07ea42869c1ac22a3ed27ebe6d4e3">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location if any, a null entity otherwise. </dd></dl>

</div>
</div>
<a id="a3161e68e4281c40c39175499c26efdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3161e68e4281c40c39175499c26efdfd">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>The returned iterator points to the first entity of the internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a11ed626f4ec3c49322751cd93e7eeeba" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the internal packed array. </dd></dl>

</div>
</div>
<a id="ae78ef32caf9f42fae6840f51de63a3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78ef32caf9f42fae6840f51de63a3c9">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a sparse set has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the sparse set. </dd></dl>

</div>
</div>
<a id="a22428127d7eed30332291187b8822a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22428127d7eed30332291187b8822a4a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb829883e484fac948f907fdf5363d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb829883e484fac948f907fdf5363d11">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

</div>
</div>
<a id="a268e0489bfee6161c78e7ecf6c343312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268e0489bfee6161c78e7ecf6c343312">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>* <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<p>The returned pointer is such that range <code>[<a class="el" href="classentt_1_1basic__sparse__set.html#a268e0489bfee6161c78e7ecf6c343312" title="Direct access to the internal packed array.">data()</a>, <a class="el" href="classentt_1_1basic__sparse__set.html#a268e0489bfee6161c78e7ecf6c343312" title="Direct access to the internal packed array.">data()</a> + <a class="el" href="classentt_1_1basic__sparse__set.html#a1dd2179ea7088d14f5ce69d7494709d3" title="Returns the number of elements in a sparse set.">size()</a>)</code> is always a valid range, even if the container is empty.</p>
<dl class="section note"><dt>Note</dt><dd>Entities are in the reverse order as returned by the <code>begin</code>/<code>end</code> iterators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

</div>
</div>
<a id="a5855f240d4e380467e6422edb9e06496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5855f240d4e380467e6422edb9e06496">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1357c27ba3d56e2d1ec10247f861640a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1357c27ba3d56e2d1ec10247f861640a">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a11ed626f4ec3c49322751cd93e7eeeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ed626f4ec3c49322751cd93e7eeeba">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p>The returned iterator points to the element following the last entity in the internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the internal packed array. </dd></dl>

</div>
</div>
<a id="a242cef78b4cdc4ad16844aa06b31bdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242cef78b4cdc4ad16844aa06b31bdd2">&#9670;&nbsp;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::extent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of a sparse set. </p>
<p>The extent of a sparse set is also the size of the internal sparse array. There is no guarantee that the internal packed array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Extent of the sparse set. </dd></dl>

</div>
</div>
<a id="aa4c8802dc54456ad6c5ad29cdb370529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c8802dc54456ad6c5ad29cdb370529">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1ec801822e07322ff37412472bc040a">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the given entity if it's found, past the end iterator otherwise. </dd></dl>

</div>
</div>
<a id="abb0f4c36135a1d52f4993701c070b9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0f4c36135a1d52f4993701c070b9a3">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

</div>
</div>
<a id="a4c63e08ff399077c5c8b9beef794e80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c63e08ff399077c5c8b9beef794e80a">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns one or more entities to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee2299701078a3d87ee4fbc61a11c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee2299701078a3d87ee4fbc61a11c61">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

</div>
</div>
<a id="af47a42337d592c6ffb548b6cdeb3c990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47a42337d592c6ffb548b6cdeb3c990">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location. </dd></dl>

</div>
</div>
<a id="a9dba8a5bd4d928ad24174537e9bccba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dba8a5bd4d928ad24174537e9bccba5">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a083b5d1855348959c94507c62e4560e3">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>The returned iterator points to the first entity of the reversed internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a94af829f6ac763b37df719b43a885ae4" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array. </dd></dl>

</div>
</div>
<a id="a9b0b4d393afe8b75c7d9d64eec662a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0b4d393afe8b75c7d9d64eec662a13">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to remove an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6be76483883a469befd13285dc286ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be76483883a469befd13285dc286ba0">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes multiple entities from a pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94af829f6ac763b37df719b43a885ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94af829f6ac763b37df719b43a885ae4">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a083b5d1855348959c94507c62e4560e3">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<p>The returned iterator points to the element following the last entity in the reversed internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed internal packed array. </dd></dl>

</div>
</div>
<a id="abbac69bb690227ebebd22fd6c998ba69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac69bb690227ebebd22fd6c998ba69">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a sparse set. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a588fd9b1e9288196c6786b5668e2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a588fd9b1e9288196c6786b5668e2f3">&#9670;&nbsp;</a></span>respect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::respect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in another sparse set. </p>
<p>Entities that are part of both the sparse sets are ordered internally according to the order they have in <code>other</code>. All the other entities goes to the end of the list and there are no guarantees on their order.<br  />
 In other terms, this function can be used to impose the same order on two sets by using one of them as a master and the other one as a slave.</p>
<p>Iterating the sparse set with a couple of iterators returns elements in the expected order after a call to <code>respect</code>. See <code>begin</code> and <code>end</code> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd2179ea7088d14f5ce69d7494709d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd2179ea7088d14f5ce69d7494709d3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a id="a2a4d0296516d1d269b3a1e77b3632048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d0296516d1d269b3a1e77b3632048">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all elements according to the given comparison function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1basic__sparse__set.html#a9172cbcd7ced65b6649224ca47b6d524" title="Sort the first count elements according to the given comparison function.">sort_n</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9172cbcd7ced65b6649224ca47b6d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9172cbcd7ced65b6649224ca47b6d524">&#9670;&nbsp;</a></span>sort_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::sort_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a4b021680642656b85abb01e503cf1361">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the first count elements according to the given comparison function. </p>
<p>The comparison function object must return <code>true</code> if the first element is <em>less</em> than the second one, <code>false</code> otherwise. The signature of the comparison function should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><p>Moreover, the comparison function object shall induce a <em>strict weak ordering</em> on the values.</p>
<p>The sort function object must offer a member function template <code>operator()</code> that accepts three arguments:</p>
<ul>
<li>An iterator to the first element of the range to sort.</li>
<li>An iterator past the last element of the range to sort.</li>
<li>A comparison function to use to compare the elements.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of elements to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa344d6da890c4e8a587f186a2872b5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa344d6da890c4e8a587f186a2872b5b9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a350b507e85eea1ee4f562374b1d47e42">entity_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in the internal packed array. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>LightFramework/libs/entt/<a class="el" href="entt_8hpp_source.html">entt.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
